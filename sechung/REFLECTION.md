# Reflection
### 정의
- Java Reflection은 구체적인 클래스 타입을 알지 못하더라도 해당 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API이다.
- Reflection을 이용하면 컴파일 시점에 존재하지 않던 클래스를 사용할 수 있고, 런타임 시점에 클래스의 메소드, 타입, 필드들에 접근할 수 있다.

### 사용 사례
- 타입 정보 얻기
    - 클래스의 이름, 부모 클래스, 구현한 인터페이스, 제네릭 타입 파라미터, 메소드, 필드, 생성자 등의 정보를 얻을 수 있다.
- 인스턴스 생성
    - Class 객체를 통해 newInstance() 메소드를 호출하면 해당 클래스의 인스턴스를 생성할 수 있다.
- 메소드 호출
    - invoke() 메소드를 통해 메소드를 호출할 수 있다.
- 필드 접근
    - Field 객체를 통해 필드에 동적으로 접근할 수 있다.
- 어노테이션
    - 런타임 시점에 어노테이션 정보를 얻을 수 있다.
- 배열 조작
    - 배열의 타입, 길이, 요소를 검사하거나 수정할 수 있다.

### Spring의 Reflection
- DI
    - Spring은 Reflection을 이용해 IoC 컨테이너를 구현하고 있다. 런타임에 클래스의 인스턴스를 생성하고, 의존성을 주입하는 것이 가능하다.
- AOP
    - 런타임에 프록시 객체를 생성하고, 프록시 객체를 생성 및 조작하여 메소드 호출 전후에 추가적인 작업을 수행할 수 있다.
- MVC
    - Spring MVC는 Reflection을 이용해 컨트롤러를 동적으로 찾고, 컨트롤러의 메소드를 호출한다.
- Annotation
    - 어노테이션을 사용한 클래스, 메소드, 필드 검사는 리플렉션을 통해 수행된다.

### Reflection의 단점 / 주의사항
- 성능
    - 런타임에 클래스의 정보를 가져오고, 메소드를 호출하기 때문에 성능이 떨어진다.
- 보안 이슈
    - private 메소드나 필드에 접근할 수 있기 때문에 보안에 취약하다. 캡슐화를 깨게 된다.
- 유지보수
    - 컴파일 시점에 타입을 검사하지 않기 때문에 유지보수가 자연스럽게 어려워진다.
- 디버깅
    -컴파일 시점에 타입을 검사하지 않기 때문에 디버깅이 어려워진다.

