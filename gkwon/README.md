# 42gg_b01

## http 메소드

주요 메소드

GET : 리소스 조회

POST: 요청 데이터 처리, 주로 등록에 사용

PUT : 리소스를 대체(덮어쓰기), 해당 리소스가 없으면 생성

PATCH : 리소스 부분 변경 (PUT이 전체 변경, PATCH는 일부 변경)

DELETE : 리소스 삭제

기타 메소드

HEAD : GET과 동일하지만 메시지 부분(body 부분)을 제외하고, 상태 줄과 헤더만 반환

OPTIONS :대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)

CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정

TRACE :대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

http 상태코드

- **1XX: Informational(정보 제공)**
    - 임시 응답으로 현재 클라이언트의 요청까지는 처리되었으니 계속 진행하라는 의미입니다. HTTP 1.1 버전부터 추가되었습니다.
- **2XX: Success(성공)**
    - 클라이언트의 요청이 서버에서 성공적으로 처리되었다는 의미입니다.
- **3XX: Redirection(리다이렉션)**
    - 완전한 처리를 위해서 추가 동작이 필요한 경우입니다. 주로 서버의 주소 또는 요청한 URI의 웹 문서가 이동되었으니 그 주소로 다시 시도하라는 의미입니다.
- **4XX: Client Error(클라이언트 에러)**
    - 없는 페이지를 요청하는 등 클라이언트의 요청 메시지 내용이 잘못된 경우를 의미합니다.
- **5XX: Server Error(서버 에러)**
    - 서버 사정으로 메시지 처리에 문제가 발생한 경우입니다. 서버의 부하, DB 처리 과정 오류, 서버에서 익셉션이 발생하는 경우를 의미합니다.

## RestAPI

일반 api와 restapi 차이

• RESTful APIs 개발하는 가장 큰 이유는 **Client Side를 정형화된 플랫폼이 아닌 모바일, PC, 어플리케이션 등 플랫폼에 제약을 두지 않는 것을 목표로 했기 때문 입니다.**

- 즉, 2010년 이전만 해도 Server Side에서 데이터를 전달해주는 Client 프로그램의 대상은 PC 브라우저로 그 대상이 명확 했다. 그렇다 보니 그냥 JSP ASP PHP 등을 잉요한 웹페이지를 구성하고 작업을 진행하면 됐다.
- 하지만 스마트 기기들이 등장하면서 TV, 스마트 폰, 테블릿 등 Client 프로그램이 다양화 되고 그에 맞춰 Server를 일일이 만다는 것이 꽤 비효율적인 일이 되어 버렸다.
- 이런 과정에서 개발자들은 Client Side를 전혀 고려하지 않고 메시지 기반, XML, JSON과 같은 **Client에서 바로 객체로 치환 가능한 형태의 데이터 통신을 지향하게 되면서 Server와 Client의 역할을 분리하게 되었다.**

Representational State Transfer = rest
**REST API는 HTTP 메소드(GET, POST, PUT, DELETE 등)를 사용하여 리소스를 조작하며, 통상적으로 JSON이나 XML 형식으로 데이터를 주고 받습니다.** 

**REST는 상태 없음(stateless), 클라이언트-서버 구조, 캐시 가능, 계층화, 코드 온 디맨드 등의 원칙을 가지고 있습니다. 이런 원칙을 따르는 API를 RESTful API라고도 부릅니다.**

**클라이언트-서버 구조: 클라이언트와 서버는 서로 독립적으로 진화해야 하며, 각자의 역할에 집중해야 합니다.**

**상태 없음(Stateless): 각 요청 간에 클라이언트의 컨텍스트가 서버에 저장되어서는 안 됩니다. 각 요청은 모든 필요한 정보를 포함해야 하며, 이는 서버가 요청을 이해하고 처리하는데 필요한 모든 것을 의미합니다.**

**캐시 가능(Cacheable): 클라이언트는 응답을 캐싱할 수 있어야 하며, 이는 성능 향상에 도움이 됩니다. 응답은 캐시 가능 여부를 명확하게 표시해야 합니다.**

**레이어드 시스템(Layered System): 클라이언트는 종단점을 제외한 네트워크의 다른 부분에 대해 알 필요가 없습니다. 중간 서버가 요청을 전달하거나 응답을 캐시할 수 있습니다.**

**코드 온 디맨드 (선택 사항): 서버는 실행 가능한 코드를 클라이언트에게 제공하여 기능을 확장할 수 있습니다.**

**Uniform Interface: API는 일관된 인터페이스를 제공해야 합니다. 이는 리소스 지향 아키텍처, 자기 설명적인 메시지 등을 포함합니다.**

## 쿠키와 세션, jwt 차이

쿠키는 서버가 데이터를 보내어 클라이언트 브라우저에 저장하는 것
대부분 클라이언트의 고유 식별자를 저장하기 위해서 사용됨

세션은 서버에 저장되는 클라이언트의 데이터
세션의 식별자를 클라이언트에게 전달하는데 쿠키가 사용될 수 있음

jwt

로그인을 하면 토큰을 발급 받아 서버에서는 아무것도 저장하지 않고 클라이언트에 해당 토큰을 전달한다.

jwt 구조 : 헤더, 페이로드, 서명
해당 토큰의 페이로드 데이터에는 서비스가 사용자에게 공개하기 원하는 데이터가 포함되어 있다.
jwt는 statelessness라는 특성을 가지고 있는데 서버에 아예 아무것도 저장을 안하는게 아니라 서명값을 대조하기 위한 해쉬값만 가지고 있으면 되기 때문에 상대적으로 서버는 적은 부하가 걸린다.
또한 서명 때문에 데이터 무결성을 보장 할 수 있다.

하지만 탈취 가능성 때문에 it 대부분 기업에서는 사용을 지양한다.

물론 숏텀,롱텀 jwt를 두개 발급을 받아 해당 취약점을 어느정도 보안하는 방법또한 있다.

## MVC model

![image](https://github.com/ghyen/42gg-onboarding-be-01/assets/79272189/4ab5e985-4f5f-495d-a262-8dbeb50cac01)


일종의 divide and conqurer이다 각 모듈로 나누고 독립시켜 유지보수성과 성능향상을 기대할 수 있다.

일련의 메커니즘 순서는 다음과 같다

1. 사용자의 Request(요청)를 Controller가 받는다.
2. Controller는 Service에서 비즈니스 로직을 처리한 후 결과를 Model에 담는다.
3. Model에 저장된 결과를 바탕으로 시각적 요소 출력을 담당하는 View를 제어하여 사용자에게 전달한다.

### Model(모델)

Model은 소프트웨어나 애플리케이션에서 정보 및 데이터 부분을 의미한다. 이는 **Controller에게 받은 데이터를 조작(가공)하는 역할을 수행**한다고 볼 수 있다. 즉, 데이터와 관련된 부분을 담당하며 값과 기능을 가지는 객체라고 보면 된다.

Model이 가지는 규칙은 다음과 같다.

> 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 한다.View나 Controller에 대해서 어떤 정보도 알지 말아야 한다.변경이 일어나면, 변경 통지에 대한 처리방법을 구현해야만 한다.
> 

### View(뷰)

View는 입력값이나 체크박스 등과 같은 사용자 인터페이스 요소를 나타낸다. 이는 **Controller에게 받은 Model의 데이터를 사용자에게 시각적으로 보여주기 위한 역할을 수행**한다. 사용자에게 보여지는 화면이라고 볼 수 있다.

View가 가지는 규칙은 다음과 같다.

> Model이 가지고 있는 정보를 따로 저장해서는 안된다.Model이나 Controller를 알고 있을 필요가 없다.변경이 일어나면 변경통지에 대한 처리방법을 구현해야만 한다.
> 

### Controller(컨트롤러)

Controller는 Model과 View 사이에서 데이터 흐름을 제어한다. 사용자가 접근한 URL에 따라 요청을 파악하고 URL에 적절한 Method를 호출하여 Service에서 비즈니스 로직을 처리한다. 이 후 결과를 Model에 저장하여 View에게 전달하는 역할을 수행한다. 결국 Controller는 **Model과 View의 역할을 분리하는 중요한 요소**이다.

이러한 Controller가 가지는 규칙은 다음과 같다.

> Model이나 View에 대해서 알고 있어야 한다.Model이나 View의 변경을 모니터링 해야 한다.
> 

위와 같이 Model, View, Controller가 어떤 역할을 수행하는지, 어떤 규칙을 가지는지를 알아보았다. **Model과 View는 각각의 역할에 충실**하지만 **Controller는 Model과 View의 흐름을 제어하기 위한 역할이 더욱 중요**하다고 느껴졌다.

MVC 모델을 추구하기 위한 규칙은 다음과 같다

1. 모델은 컨트롤러나 뷰에 의존하면 안된다.
    - 모델 내부에 컨트롤러 및 뷰와 관련된 코드가 있으면 안된다.
2. 뷰는 모델에만 의존해야 하고, 컨트롤러에는 의존하면 안된다.
    - 뷰 내부에 모델의 코드만 있을 수 있고, 컨트롤러의 코드가 있으면 안된다.
3. 뷰가 모델로부터 데이터를 받을 때는 사용자마다 다르게 보여주어야 하는 데이터에 한해서만 받아야 한다.
4. 컨트롤러는 모델과 뷰에 의존해도 된다.
    - 컨트롤러 내부에는 모델과 뷰의 코드가 있을 수 있다.
5. 뷰가 모델로부터 데이터를 받을 때는 반드시 컨트롤러에서 받아야 한다.

인증 인가 차이

인증은 who are you

인가는 what can you do

## 인프라

- HTTPS
    - HTTPS는 HTTP 요청 및 응답을 SSL 및 TLS(보안 인증서) 기술에 결합한 것을 의미.
    - HTTPS 메커니즘
        1. 사용자 브라우저의 주소 표시줄에 *https://* URL 형식을 입력하여 HTTPS 웹 사이트를 방문합니다.
        2. 브라우저는 서버의 SSL 인증서를 요청하여 사이트의 신뢰성을 검증하려고 시도합니다.
        3. 서버는 퍼블릭 키가 포함된 SSL 인증서를 회신으로 전송합니다.
        4. 웹 사이트의 SSL 인증서는 서버 아이덴티티를 증명합니다. 브라우저에서 인증되면, 브라우저가 퍼블릭 키를 사용하여 비밀 세션 키가 포함된 메시지를 암호화하고 전송합니다.
        5. 웹 서버는 개인 키를 사용하여 메시지를 해독하고 세션 키를 검색합니다. 그런 다음, 세션 키를 암호화하고 브라우저에 승인 메시지를 전송합니다.
        6. 이제 브라우저와 웹 서버 모두 동일한 세션 키를 사용하여 메시지를 안전하게 교환하도록 전환합니다.

- DNS 서버
    - 도메인 주소→ ip 주소로 변환하는 기능

- CI/CD
    - CI/CD (Continuous Integration/Continuous Delivery)는 [애플리케이션 개발](https://www.redhat.com/ko/topics/devops/[[url-nid:307771;title:'article%20%7C%20why%20choose%20red%20hat%20for%20cloud-native%20development?%27]) 단계를 [자동화](https://www.redhat.com/ko/topics/automation?cicd=32h281b)하여 [애플리케이션](https://www.redhat.com/ko/topics/cloud-native-apps?percmp=7013a0000034e7YAAQ&cicd=32h281b)을 더욱 짧은 주기로 고객에게 제공하는 방법
    - CI/CD의 기본 개념은 지속적인 통합, [지속적인 서비스 제공](https://www.redhat.com/ko/topics/devops/what-is-continuous-delivery?cicd=32h281b), 지속적인 배포
    - CI/CD와 관련해 가장 널리 알려진 오픈소스 툴은 Jenkins 자동화 서버
