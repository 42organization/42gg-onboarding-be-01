# 쿠키와 세션

## HTTP의 특징과 쿠키와 세션을 사용하는 이유

- 기본적으로 HTTP 환경은 “**connectionless, stateless**”한 특성을 가짐 → 서버는 클라이언트가 누구인지 매번 확인할 필요 O
    - **connectionless (비연결성)**
        - 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어 버리는 특징
    - **stateless (무상태성)**
        - 통신이 끝나면 상태를 유지하지 않는 특징
    
    <aside>
    💡 쿠키와 세션은 위의 두 가지 특징을 해결하기 위해 사용한다.
    쿠키와 세션을 사용했을 경우, 한 번 로그인을 하면 어떠한 방식에 의해서 그 사용자에 대한 인증을 유지하게 된다.
    
    </aside>
    

## 쿠키(Cookie)

### 쿠키란?

- **클라이언트(브라우저) 로컬에 저장**되는 키와 값이 들어있는 작은 데이터 파일
- HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가 **필요시 정보를 참조하거나 재사용할 수 있다.**
- 클라이언트에 300개까지 쿠키저장 가능, 하나의 도메인당 20개의 값만 가질 수 있음, 하나의 쿠키값은 4KB까지 저장 가능

### 쿠키의 구성 요소

- 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름
- 값 : 쿠키의 이름과 관련된 값
- 유효시간 : 쿠키의 유지시간
- 도메인 : 쿠키를 전송할 도메인
- 경로 : 쿠키를 전송할 요청 경로

### 쿠키의 동작 방식

1. 클라이언트가 페이지를 요청
2. 서버에서 쿠키를 생성
3. HTTP 헤더에 쿠키를 포함 시켜 응답
4. **브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음**
5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

### 쿠키의 사용 예

- 자동 로그인
- 쇼핑몰의 장바구니 기능
- 팝업에서 "오늘 더 이상 이 창을 보지 않음" 체크

## 세션(Session)

### 세션이란?

- 일정 시간동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술
    - 여기서 일정 시간은 방문자가 **웹 브라우저를 통해 웹 서버에 접속한 시점으로부터 웹 브라우저를 종료하여 연결을 끝내는 시점**을 말한다.
- 즉, **방문자가 웹 서버에 접속해 있는 상태 == 세션**

### **세션의 동작 순서**

1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)
2. 서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여, 클라이언트가 해당 session-id를 보냈는지 확인한다.
3. session-id가 존재하지 않는다면, 서버는 session-id를 생성해 클라이언트에게 돌려준다.
4. 서버에서 클라이언트로 돌려준 session-id를 쿠키를 사용해 서버에 저장한다. 쿠키 이름 : JSESSIONID
5. 클라이언트는 재접속 시, 이 쿠키(JSESSIONID)를 이용하여 session-id 값을 서버에 전달

### 세션의 사용 예

화면이 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지

## **쿠키와 세션 차이**

|  | 쿠키(Cookie) | 세션(Session) |
| --- | --- | --- |
| 저장 위치 | 클라이언트(=접속자 PC) | 웹 서버 |
| 저장 형식 | text | Object |
| 만료 시점 | 쿠키 저장 시 설정(브라우저가 종료되어도, 만료 시점이 지나지 않으면 자동 삭제되지 않음) | 브라우저 종료 시 삭제(기간 지정 가능) |
| 사용하는 자원(리소스) | 클라이언트 리소스 | 웹 서버 리소스 |
| 용량 제한 | 총 300개하나의 도메인 당 20개하나의 쿠키 당 4KB(=4096byte) | 서버가 허용하는 한 용량제한 없음. |
| 속도 | 세션보다 빠름 | 쿠키보다 느림 |
| 보안 | 세션보다 안 좋음 | 쿠키보다 좋음 |
- 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷하다.
    - 그 이유는 세션도 결국 쿠키를 사용하기 때문이다.
- 세션을 사용하면 좋은데 왜 쿠키를 사용할까?
    - 세션은 **서버의 자원을 사용하기 때문에** 무분별하게 만들다보면 서버의 메모리가 감당할 수 없어질 수가 있고 속도가 느려질 수 있기 때문이다.
# JWT(Json Web Token)

> 정보를 비밀리에 전달하거나 인증할 때 주로 사용하는 토큰으로, **Json** 객체를 이용함
> 

일반적으로 클라이언트와 서버 사이에서 통신할 때 권한을 위해 사용하는 토큰이다. 웹 상에서 정보를 Json 형태로 주고 받기 위해 표준 규약에 따라 생성한 암호화된 토큰으로 복잡하고 읽을 수 없는 string 형태로 저장되어 있다.

## 세션의 단점을 보완하기 위해 등장

### 세션의 단점

1. 세션 저장소에 문제 발생 시, 인증 체계가 무너져 이전에 다른 인증된 유저 또한 인증 불가해짐
2. stateful하기 때문에 http의 장점 발휘하지 못 함(scale out에 걸림돌 생김)
3. 세션 저장소가 필수적으로 존재 → 사용하기 위한 비용 발생
4. 세션 ID 탈취되었을 경우, 대처 가능하지만 클라이언트인 척 위장하는 보안의 약점 존재 가능성
5. 사용자가 많아질수록 많은 메모리 차지
6. ‘매번’ 요청 시 세션 저장소를 조회해야 함

## JWT의 구조

JWT는 **헤더(header)**, **페이로드(payload)**, **서명(signature)** 세 파트로 나눠져 있으며, 아래와 같은 형태로 구성되어 있다.

![스크린샷 2023-10-13 오후 2.42.28.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aeeca2cb-aa13-47dd-b9ce-d069c288dc24/4c2718a3-72d7-4ce6-bd0f-e4ca2d6b9420/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.42.28.png)

### 헤더 (Header)

> 토큰의 타입 / 서명 생성에 사용되는 알고리즘의 정보 포함
> 

![스크린샷 2023-10-13 오후 2.43.36.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aeeca2cb-aa13-47dd-b9ce-d069c288dc24/80cf7c51-8ffc-42b3-a64c-074085d842a2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.43.36.png)

### 정보 (Payload)

> 전달하려는 정보(사용자 id나 다른 데이터들 == 클레임) 포함
> 

![스크린샷 2023-10-13 오후 2.45.40.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aeeca2cb-aa13-47dd-b9ce-d069c288dc24/55b1e242-f2f9-49c3-8ca9-ffe21b0cb9f3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.45.40.png)

- Claim의 표준 스펙 (꼭 포함되어야 하는 것 X)
    1. iss(Issuer): 토큰 발급자
    2. sub(Subject): 토큰 제목 - 토큰에서 사용자에 대한 식별 값이 됨
    3. aud(Audience): 토큰 대상자
    4. exp(Expiration Time): 토큰 만료 시간
    5. nbf(Not Before): 토큰 활성 날짜(이 날짜 이전의 토큰은 활성화되지 않음 보장)
    6. iat(Issued At): 토큰 발급 시간
    7. jti(JWT Id): JWT 토큰 식별자(issuer가 여러 명일 때 이를 구분하기 위한 값)
- payload에 있는 내용은 수정이 가능하여 더 많은 정보를 추가할 수 있다. 그러나 **노출과 수정이 가능한 지점**이기 때문에 **인증이 필요한 최소한의 정보**(아이디, 비밀번호 등 **개인정보가 아닌** 이 토큰을 가졌을 때 권한의 범위나 토큰의 발급일과 만료일자 등)만을 담아야 한다.

### 서명 (Signature)

![스크린샷 2023-10-13 오후 3.40.12.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aeeca2cb-aa13-47dd-b9ce-d069c288dc24/8e879636-7fc0-401b-872e-6e0825c25545/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.40.12.png)

> 가장 중요한 부분으로 헤더와 정보를 합친 후 발급해준 서버가 지정한 **secret key로 암호화시켜 토큰을 변조하기 어렵게 만들어준다.**
> 

ex) 토큰이 발급된 후, 누군가 Payload의 정보 수정

→ **Payload**에는 **조작된 정보**가 들어가 있지만, **Signatute**에는 **조작 전 Payload 내용**을 기반으로 이미 암호화 되어 있는 결과가 저장되어 있음

→  조작되어 있는 Payload와는 다른 결과값 나옴

→ 이러한 방식으로 비교하면 **서버는 토큰이 조작되었는지 아닌지를 쉽게 알 수 있고, 다른 누군가는 조작된 토큰을 악용하기가 어려워진다.**

## JWT의 동작 원리

![스크린샷 2023-10-13 오후 3.45.19.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aeeca2cb-aa13-47dd-b9ce-d069c288dc24/179bc927-1d3c-40a6-9d85-061597f5271b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.45.19.png)

1. 사용자가 id와 password를 입력하여 로그인 요청을 한다.
2. 서버는 회원 DB에 들어가 있는 사용자인지 확인을 한다.
3. 확인이 되면 서버는 로그인 요청 확인 후, secret key를 통해 토큰을 발급한다.
4. 이것을 클라이언트에 전달한다.
5. 서비스 요청과 권한을 확인하기 위해서 헤더에 데이터(JWT) 요청을 한다.
6. 데이터를 확인하고 JWT에서 사용자 정보를 확인한다.
7. 클라이언트 요청에 대한 응답과 요청한 데이터를 전달해준다.

## JWT의 장점

- **stateful** 해야 하는 **세션의 단점을 보완**하기 위해 만들어진 JWT는 이미 토큰 자체가 인증된 정보이기 때문에 **별도의 세션 저장소가 필수적으로 필요 X**
- signature를 공통 키, 개인 키 암호화를 통해 막아두었기에 **보안성** ↑

## JWT의 단점

- base64 인코딩을 통한 정보 전달 → 전달량이 많음 → 부하 가능성 ↑
- Payload에는 암호화가 되어 있지 않음 → 민감한 정보 저장 X
- **토큰이 탈취당하면 만료될 때까지 대처 불가**
    - 해결: JWT의 exp(만료 시간)을 단축시키기